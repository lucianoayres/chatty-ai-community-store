name: Update Agent Index

on:
  push:
    branches:
      - main
    paths:
      - "agents/**.yaml"
      - "agents/**.yml"

jobs:
  update-index:
    name: Update Agent Index
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for proper comparison

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          pip install pyyaml jsonschema yamale

      # STAGE 1: VALIDATION
      - name: "📋 STAGE 1: VALIDATE AGENT FILES"
        run: echo "Beginning validation of changed agent files..."

      - name: Find changed agent files
        id: find-files
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep "^agents/" | grep -E "\.(yaml|yml)$" || echo "")
          echo "Changed agent files:"
          echo "$CHANGED_FILES"

          if [ -z "$CHANGED_FILES" ]; then
            echo "No agent YAML files were changed."
            echo "changed_files_count=0" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            COUNT=$(echo "$CHANGED_FILES" | wc -l)
            echo "changed_files_count=$COUNT" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "files<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Validate changed agent files
        id: validation
        if: steps.find-files.outputs.has_changes == 'true'
        continue-on-error: true
        run: |
          # Setup validation environment
          export PYTHONPATH="$PWD/tools/agent_manager/src:$PYTHONPATH"

          # Create validation logs directory
          mkdir -p validation_logs
          VALIDATION_LOG="validation_logs/validation_results.txt"
          ERROR_SUMMARY="validation_logs/error_summary.txt"

          # Create a simple Python script to validate and print errors
          cat > validate_and_print.py << 'EOF'
          #!/usr/bin/env python3
          import sys
          import os
          import yaml
          import yamale
          from validator import AgentValidator

          def validate_file(file_path, schema_path, tag_definitions_path):
              print(f"\n\n===== VALIDATING {file_path} =====")
              
              # Create validator
              validator = AgentValidator(
                  schema_path,
                  tag_definitions_path=tag_definitions_path,
                  error_log_path="validation_logs/errors.log"
              )
              
              # First try to load the YAML file
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      file_content = f.read()
                  
                  try:
                      data = yaml.safe_load(file_content)
                      
                      # Check if it's a dictionary
                      if not isinstance(data, dict):
                          print("Error: YAML file must contain a dictionary")
                          return False
                      
                      # Load the schema directly
                      schema = yamale.make_schema(schema_path)
                      
                      # Validate against schema
                      try:
                          yamale.validate(schema, [(data, file_path)])
                          print(f"✅ Schema validation passed for {file_path}")
                      except ValueError as e:
                          print(f"Error: YAML schema validation error: {str(e)}")
                          
                          # Check for specific schema requirements
                          with open(schema_path, 'r') as schema_file:
                              schema_content = schema_file.read()
                              print("\nSchema requirements:")
                              for line in schema_content.split('\n'):
                                  if 'required=True' in line and '#' in line:
                                      field = line.split(':')[0].strip()
                                      comment = line.split('#')[1].strip()
                                      print(f"  - {field}: {comment}")
                          
                          # Check for missing required fields
                          required_fields = ['name', 'emoji', 'description', 'system_message',
                                           'label_color', 'text_color', 'is_default', 'tags']
                          missing_fields = [field for field in required_fields if field not in data]
                          if missing_fields:
                              print(f"\nError: Missing required fields: {', '.join(missing_fields)}")
                          
                          # Check field constraints
                          if 'name' in data and isinstance(data['name'], str):
                              if len(data['name']) > 40:
                                  print(f"Error: 'name' field exceeds maximum length (40 chars): {len(data['name'])}")
                          
                          if 'description' in data and isinstance(data['description'], str):
                              if len(data['description']) > 65:
                                  print(f"Error: 'description' field exceeds maximum length (65 chars): {len(data['description'])}")
                          
                          if 'emoji' in data:
                              if not isinstance(data['emoji'], str) or len(data['emoji']) != 1:
                                  print("Error: 'emoji' field must be exactly one character")
                          
                          if 'system_message' in data and isinstance(data['system_message'], str):
                              if len(data['system_message']) > 1500:
                                  print(f"Error: 'system_message' field exceeds maximum length (1500 chars): {len(data['system_message'])}")
                          
                          # Check tags
                          if 'tags' in data:
                              if not isinstance(data['tags'], list):
                                  print("Error: 'tags' field must be a list")
                              elif len(data['tags']) < 1:
                                  print("Error: 'tags' field must have at least one tag")
                              elif not validator.tag_manager.validate_tags(data['tags']):
                                  invalid_tags = [t for t in data['tags'] 
                                                if t not in validator.tag_manager.get_valid_tags()]
                                  print(f"Error: Invalid tags: {', '.join(invalid_tags)}")
                                  print(f"Valid tags are: {', '.join(validator.tag_manager.get_valid_tags())}")
                          
                          return False
                      
                      # If we got here, the file passed schema validation
                      # Now check for any additional validation rules
                      
                      # Validate tags again to be sure
                      if 'tags' in data:
                          if not validator.tag_manager.validate_tags(data['tags']):
                              invalid_tags = [t for t in data['tags'] 
                                            if t not in validator.tag_manager.get_valid_tags()]
                              print(f"Error: Invalid tags: {', '.join(invalid_tags)}")
                              print(f"Valid tags are: {', '.join(validator.tag_manager.get_valid_tags())}")
                              return False
                      
                      print(f"✅ {file_path} is valid")
                      return True
                      
                  except yaml.YAMLError as e:
                      print(f"Error: YAML parsing error: {str(e)}")
                      return False
                  
              except Exception as e:
                  print(f"Error: Failed to analyze file: {str(e)}")
                  return False

          def main():
              if len(sys.argv) < 4:
                  print("Usage: python validate_and_print.py <file_path> <schema_path> <tag_definitions_path>")
                  sys.exit(1)
                  
              file_path = sys.argv[1]
              schema_path = sys.argv[2]
              tag_definitions_path = sys.argv[3]
              
              if not os.path.exists(file_path):
                  print(f"Error: File not found: {file_path}")
                  sys.exit(1)
                  
              success = validate_file(file_path, schema_path, tag_definitions_path)
              sys.exit(0 if success else 1)

          if __name__ == "__main__":
              main()
          EOF

          chmod +x validate_and_print.py

          # Initialize error summary
          echo "# Validation Error Summary" > $ERROR_SUMMARY
          echo "" >> $ERROR_SUMMARY

          FAIL_COUNT=0

          # Get the list of files to validate
          IFS=$'\n' read -d '' -ra FILES <<< "${{ steps.find-files.outputs.files }}"

          for file in "${FILES[@]}"; do
            # Run the validator script
            python validate_and_print.py "$file" "schemas/agent.schema.yaml" "tags.json" | tee -a $VALIDATION_LOG
            
            VALIDATION_EXIT_CODE=${PIPESTATUS[0]}
            
            # Check if validation failed
            if [ $VALIDATION_EXIT_CODE -ne 0 ]; then
              FAIL_COUNT=$((FAIL_COUNT+1))
              
              # Add to error summary
              echo "## ❌ File: $file" >> $ERROR_SUMMARY
              echo '```' >> $ERROR_SUMMARY
              python validate_and_print.py "$file" "schemas/agent.schema.yaml" "tags.json" | grep "Error:" >> $ERROR_SUMMARY
              echo '```' >> $ERROR_SUMMARY
              echo "" >> $ERROR_SUMMARY
            else
              echo "## ✅ File: $file" >> $ERROR_SUMMARY
              echo "Passed all validation checks" >> $ERROR_SUMMARY
              echo "" >> $ERROR_SUMMARY
            fi
          done

          # Determine overall result
          if [ $FAIL_COUNT -gt 0 ]; then
            # Print error summary to make it clearly visible in workflow logs
            echo ""
            echo "============================================="
            echo "❌ VALIDATION FAILED: $FAIL_COUNT files have issues"
            echo "============================================="
            echo ""
            # Display the error summary in the console
            cat $ERROR_SUMMARY
            
            # Save the outputs
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "fail_count=$FAIL_COUNT" >> $GITHUB_OUTPUT
            echo "error_summary<<EOF" >> $GITHUB_OUTPUT
            cat $ERROR_SUMMARY >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Set exit code but don't exit immediately
            exit_code=1
          else
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            echo "✅ All agent files passed validation!"
            exit_code=0
          fi

          # Store the exit code for later steps to check
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT

          # Exit with the appropriate code
          exit $exit_code

      - name: Upload validation results
        if: steps.find-files.outputs.has_changes == 'true' && (steps.validation.outputs.validation_passed == 'false' || failure())
        uses: actions/upload-artifact@v4
        with:
          name: validation-results
          path: validation_logs/

      - name: Validation summary
        if: steps.find-files.outputs.has_changes == 'true' && always()
        run: |
          echo "=== VALIDATION SUMMARY ==="
          if [[ "${{ steps.validation.outputs.validation_passed }}" == "true" ]]; then
            echo "✅ Validation PASSED - All agent files are valid"
          else
            echo "❌ Validation FAILED - Some files had issues"
            
            # Display the error summary if it exists
            if [ -f "validation_logs/error_summary.txt" ]; then
              echo ""
              echo "=== VALIDATION ERROR DETAILS ==="
              cat validation_logs/error_summary.txt
              echo "================================"
            fi
          fi

      # STAGE 2: INDEX UPDATE
      - name: "📝 STAGE 2: UPDATE AGENT INDEX"
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.validation.outputs.exit_code == '0'
        run: echo "All files validated successfully! Beginning index update..."

      - name: Run manage_agents.sh script
        id: update-index
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.validation.outputs.exit_code == '0'
        run: |
          echo "Running manage_agents.sh script to update index..."

          # Make sure script is executable
          chmod +x tools/agent_manager/manage_agents.sh

          # Run the script with verbose output
          bash -x tools/agent_manager/manage_agents.sh

          echo "Script execution complete"

          # Check if index file was modified
          if git diff --name-only | grep -q "agent_index.json"; then
            echo "index_updated=true" >> $GITHUB_OUTPUT
            echo "Agent index was updated!"
          else
            echo "index_updated=false" >> $GITHUB_OUTPUT
            echo "No changes to agent index."
          fi

      # STAGE 3: COMMIT & NOTIFY
      - name: "🚀 STAGE 3: COMMIT & NOTIFY"
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.update-index.outputs.index_updated == 'true' && steps.validation.outputs.exit_code == '0'
        run: echo "Index updated successfully! Committing changes and notifying..."

      - name: Commit updated index
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.update-index.outputs.index_updated == 'true' && steps.validation.outputs.exit_code == '0' && success()
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add and commit the changes
          git add agent_index.json
          git commit -m "🤖 Auto-update agent index [skip ci]" -m "Triggered by commit ${GITHUB_SHA}"

          # Push the changes
          git push

      - name: Find related PR
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.update-index.outputs.index_updated == 'true' && steps.validation.outputs.exit_code == '0' && success()
        id: find-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            // Find the most recent PR that was merged into this branch
            const query = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) {
                  pullRequests(last:10, states:MERGED, orderBy:{field:UPDATED_AT, direction:DESC}) {
                    nodes {
                      number
                      title
                      mergedAt
                      url
                      mergeCommit {
                        oid
                      }
                    }
                  }
                }
              }
            `;

            const variables = {
              owner: context.repo.owner,
              repo: context.repo.repo
            };

            const result = await github.graphql(query, variables);
            const prs = result.repository.pullRequests.nodes;

            // Try to find a PR that matches the current commit
            let relatedPR = null;
            const targetCommit = context.payload.after;

            for (const pr of prs) {
              if (pr.mergeCommit && pr.mergeCommit.oid === targetCommit) {
                relatedPR = pr;
                break;
              }
            }

            if (relatedPR) {
              core.setOutput('pr_number', relatedPR.number);
              core.setOutput('pr_title', relatedPR.title);
              core.setOutput('pr_url', relatedPR.url);
              return relatedPR;
            } else {
              console.log('Could not find related PR for this commit');
              return null;
            }

      - name: Comment on PR
        if: steps.find-files.outputs.has_changes == 'true' && steps.validation.outputs.validation_passed == 'true' && steps.update-index.outputs.index_updated == 'true' && steps.find-pr.outputs.pr_number != '' && steps.validation.outputs.exit_code == '0' && success()
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const prNumber = ${{ steps.find-pr.outputs.pr_number }};

            if (!prNumber) {
              console.log('No PR number found, skipping comment');
              return;
            }

            const body = `## 🤖 Agent Index Updated

            The agent index has been automatically updated following the merge of this PR.

            [View the updated index](${context.payload.repository.html_url}/blob/main/agent_index.json)
            `;

            github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      # ERROR HANDLING
      - name: Create issue for validation failure
        if: steps.find-files.outputs.has_changes == 'true' && (steps.validation.outputs.validation_passed == 'false' || steps.validation.outputs.exit_code == '1')
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const fs = require('fs');

            // Get the error summary which is already concise
            let errorSummary = '';

            try {
              errorSummary = '${{ steps.validation.outputs.error_summary }}';
              
              // If errorSummary is empty or too short, read from the file
              if (!errorSummary || errorSummary.length < 10) {
                errorSummary = fs.readFileSync('validation_logs/error_summary.txt', 'utf8');
              }
            } catch (error) {
              errorSummary = 'Error reading validation summary: ' + error.message;
            }

            const issue = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 Agent validation failed on direct push to main',
              body: `One or more agent YAML files that were pushed directly to the main branch failed validation.
              
              **⚠️ The agent index was NOT updated due to validation failure.**
              
              Triggered by: ${context.payload.head_commit.message}
              Commit: ${context.payload.head_commit.id}
              Workflow run: ${context.payload.repository.html_url}/actions/runs/${context.runId}
              
              ## Validation Error Summary
              
              \`\`\`
              ${errorSummary}
              \`\`\`
              
              Please fix the validation issues and push again, or create a PR to resolve the issues.
              
              > **Note**: Full validation logs are available in the workflow run artifacts.
              `
            };

            github.rest.issues.create(issue);

      - name: Notify on failure
        if: steps.find-files.outputs.has_changes == 'true' && failure() && steps.validation.outputs.validation_passed != 'false' && steps.validation.outputs.exit_code != '1'
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const issue = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 Failed to update agent index',
              body: `The workflow to update the agent index failed due to an unexpected error.
              
              Triggered by: ${context.payload.head_commit.message}
              Commit: ${context.payload.head_commit.id}
              Workflow run: ${context.payload.repository.html_url}/actions/runs/${context.runId}
              
              Please investigate and fix the issue.`
            };

            github.rest.issues.create(issue);
